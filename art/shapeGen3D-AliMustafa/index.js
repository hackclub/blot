/*
@title: shapeGen3D
@author: Ali Mustafa
@snapshot: ShapeGen1.png
*/
const width = 125;
const height = 125;
setDocDimensions(width, height);
const shape = 'tesseract'; //choose between tesseract, cube, or pyrmid
const focalLength = 126; // how close your perspective is to the art (distance of camera)

const pyrHeight = 1; // if pyramid is chosen changes it's height
const scale = 15.7; //size of each shape
const [rx, ry, rz] = [0, 141, 141]; //rotation in the x, y and z axes

// Note: Vertex and Edge tables generated by AI
// (because typing them out is insane)
class Shape {
  constructor(vertices, edges, offsetX = 0, offsetY = 0, offsetZ = 0, rotationX = 0, rotationY = 0, rotationZ = 0, scale = 1) {
    this.vertices = vertices.map(vertex => vertex.map(coord => coord * scale)); //scaling vertices
    this.edges = edges;
    this.applyInitialTransformations(offsetX, offsetY, offsetZ, rotationX, rotationY, rotationZ);
  }

  applyInitialTransformations(offsetX, offsetY, offsetZ, rotationX, rotationY, rotationZ) {
    //apply's all transformations once
    this.recenterVertices(offsetX, offsetY, offsetZ);
    this.rotateShape('x', rotationX);
    this.rotateShape('y', rotationY);
    this.rotateShape('z', rotationZ);
  }

  recenterVertices(offsetX, offsetY, offsetZ) {
    //changes the location (which changes perspective)
    for (let i = 0; i < this.vertices.length; i++) {
      this.vertices[i][0] += offsetX;
      this.vertices[i][1] += offsetY;
      this.vertices[i][2] += offsetZ;
    }
  }

  rotateShape(axis, angle) {
    //using 2d rotation matrix for each pair of points per respective axis
    //exculding that axes point ( x rotation ignores x value, etc. )
    angle /= 180;
    for (let i = 0; i < this.vertices.length; i++) {
      switch (axis) {
        case 'x':
          this.vertices[i] = this.rotateX(this.vertices[i], angle);
          break;
        case 'y':
          this.vertices[i] = this.rotateY(this.vertices[i], angle);
          break;
        case 'z':
          this.vertices[i] = this.rotateZ(this.vertices[i], angle);
          break;
      }
    }
  }

  rotatePoint(a, b, angle) {
    const rotA = a * Math.cos(angle) - b * Math.sin(angle);
    const rotB = a * Math.sin(angle) + b * Math.cos(angle);
    return [rotA, rotB];
  }

  rotateX(vertex, angle) {
    const [x, y, z] = vertex;
    const [rotY, rotZ] = this.rotatePoint(y, z, angle);
    return [x, rotY, rotZ];
  }

  rotateY(vertex, angle) {
    const [x, y, z] = vertex;
    const [rotX, rotZ] = this.rotatePoint(x, z, angle);
    return [rotX, y, rotZ];
  }

  rotateZ(vertex, angle) {
    const [x, y, z] = vertex;
    const [rotX, rotY] = this.rotatePoint(x, y, angle);
    return [rotX, rotY, z];
  }

  proj2D(vertex) {
    //using weak-perspective projection centered at the middle of the screen
    const [x, y, z] = vertex;
    const projVertX = x * focalLength / (z + focalLength) + width / 2;
    const projVertY = y * focalLength / (z + focalLength) + height / 2;
    return [projVertX, projVertY];
  }

  draw3DEdges() {
    //follows instructions from edge table to draw from whichever point
    for (let i = 0; i < this.edges.length; i++) {
      const edge = this.edges[i];
      const startPoint = this.proj2D(this.vertices[edge[0]]);
      const endPoint = this.proj2D(this.vertices[edge[1]]);
      drawLines([
        [startPoint, endPoint]
      ]);
    }
  }
}

//children with their own edge and vertex tables

class Cube extends Shape {
  constructor(offsetX = 0, offsetY = 0, offsetZ = 0, rotationX = 0, rotationY = 0, rotationZ = 0, scale = 1) {
    const cubeVertices = [
      [-0.5, -0.5, -0.5],
      [0.5, -0.5, -0.5],
      [0.5, 0.5, -0.5],
      [-0.5, 0.5, -0.5],
      [-0.5, -0.5, 0.5],
      [0.5, -0.5, 0.5],
      [0.5, 0.5, 0.5],
      [-0.5, 0.5, 0.5]
    ];
    const cubeEdges = [
      [0, 1],
      [1, 2],
      [2, 3],
      [3, 0],
      [4, 5],
      [5, 6],
      [6, 7],
      [7, 4],
      [0, 4],
      [1, 5],
      [2, 6],
      [3, 7]
    ];
    super(cubeVertices, cubeEdges, offsetX, offsetY, offsetZ, rotationX, rotationY, rotationZ, scale);
  }
}

class Pyramid extends Shape {
  constructor(offsetX = 0, offsetY = 0, offsetZ = 0, rotationX = 0, rotationY = 0, rotationZ = 0, scale = 1, height = 55) {
    const pyramidVertices = [
      [-0.5 * scale, 0, -0.5 * scale],
      [0.5 * scale, 0, -0.5 * scale],
      [0.5 * scale, 0, 0.5 * scale],
      [-0.5 * scale, 0, 0.5 * scale],
      [0, height * scale, 0]
    ];
    const pyramidEdges = [
      [0, 1],
      [1, 2],
      [2, 3],
      [3, 0],
      [0, 4],
      [1, 4],
      [2, 4],
      [3, 4]
    ];
    super(pyramidVertices, pyramidEdges, offsetX, offsetY, offsetZ, rotationX, rotationY, rotationZ, 1);
  }
}

class Tesseract extends Shape {
  constructor(offsetX = 0, offsetY = 0, offsetZ = 0, rotationX = 0, rotationY = 0, rotationZ = 0, scale = 1) {
    const tesseractVertices = [
      // Vertices of the outer cube
      [-0.5, -0.5, -0.5],
      [0.5, -0.5, -0.5],
      [0.5, 0.5, -0.5],
      [-0.5, 0.5, -0.5],
      [-0.5, -0.5, 0.5],
      [0.5, -0.5, 0.5],
      [0.5, 0.5, 0.5],
      [-0.5, 0.5, 0.5],
      // Vertices of the inner cube (scaled down)
      [-0.25, -0.25, -0.25],
      [0.25, -0.25, -0.25],
      [0.25, 0.25, -0.25],
      [-0.25, 0.25, -0.25],
      [-0.25, -0.25, 0.25],
      [0.25, -0.25, 0.25],
      [0.25, 0.25, 0.25],
      [-0.25, 0.25, 0.25]
    ];
    const tesseractEdges = [
      // Outer cube edges
      [0, 1],
      [1, 2],
      [2, 3],
      [3, 0],
      [4, 5],
      [5, 6],
      [6, 7],
      [7, 4],
      [0, 4],
      [1, 5],
      [2, 6],
      [3, 7],
      // Inner cube edges
      [8, 9],
      [9, 10],
      [10, 11],
      [11, 8],
      [12, 13],
      [13, 14],
      [14, 15],
      [15, 12],
      [8, 12],
      [9, 13],
      [10, 14],
      [11, 15],
      // Connections between outer and inner cubes
      [0, 8],
      [1, 9],
      [2, 10],
      [3, 11],
      [4, 12],
      [5, 13],
      [6, 14],
      [7, 15]
    ];
    super(tesseractVertices, tesseractEdges, offsetX, offsetY, offsetZ, rotationX, rotationY, rotationZ, scale);
  }
}
// x, y, z, rx, ry, rz, height(for pyramid), scale

var shapeArr = []
//drawing 3d grid of 27 shapes
for (let x = 0; x < 3; x++) {
  for (let y = 0; y < 3; y++) {
    for (let z = 0; z < 3; z++) {
      switch (shape) {
        case "tesseract":
          shapeArr.push(new Tesseract(-25 + 25 * x, -25 + 25 * y, -25 + 25 * z, rx, ry, rz, scale));
          break;
        case "cube":
          shapeArr.push(new Cube(-25 + 25 * x, -25 + 25 * y, -25 + 25 * z, rx, ry, rz, scale));
          break;
        case "pyramid":
          shapeArr.push(new Pyramid(-25 + 25 * x, -25 + 25 * y, -25 + 25 * z, rx, ry, rz, pyrHeight, scale));
          break;
      }
    }
  }
}
for (let i = 0; i < shapeArr.length; i++) {
  shapeArr[i].draw3DEdges();
}